<!doctype html><html lang=en><head><title>Goroutines in a Mine :: </title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Asynchronous Workloads Using Goroutines"><meta name=keywords content="go,golang,goroutines,asynchronous"><meta name=robots content="noodp"><link rel=canonical href=https://williamcook.dev/posts/goroutines-in-a-mine/><link rel=stylesheet href=https://williamcook.dev/assets/style.css><link rel=stylesheet href=https://williamcook.dev/assets/pink.css><link rel=apple-touch-icon href=https://williamcook.dev/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://williamcook.dev/img/favicon/pink.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Goroutines in a Mine"><meta property="og:description" content="Asynchronous Workloads Using Goroutines"><meta property="og:url" content="https://williamcook.dev/posts/goroutines-in-a-mine/"><meta property="og:site_name" content><meta property="og:image" content="https://williamcook.dev/img/favicon/pink.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2024-09-22 22:02:04 -0400 -0400"></head><body class=pink><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>William George Cook</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>About</a></li><li><a href=/contact>Contact</a></li><li><a href=/posts>Posts</a></li><li><a href=/showcase>Public Projects</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>About</a></li><li><a href=/contact>Contact</a></li><li><a href=/posts>Posts</a></li><li><a href=/showcase>Public Projects</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://williamcook.dev/posts/goroutines-in-a-mine/>Goroutines in a Mine</a></h1><div class=post-meta><span class=post-date>2024-09-22
</span><span class=post-author>:: William George Cook</span></div><span class=post-tags>#<a href=https://williamcook.dev/tags/go/>go</a>&nbsp;
#<a href=https://williamcook.dev/tags/golang/>golang</a>&nbsp;
#<a href=https://williamcook.dev/tags/goroutines/>goroutines</a>&nbsp;
#<a href=https://williamcook.dev/tags/asynchronous/>asynchronous</a>&nbsp;</span><div class=post-content><div><h1 id=a-canary-in-a-gem-mine>A Canary? In a Gem Mine?<a href=#a-canary-in-a-gem-mine class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Goroutines are, for me, <em>the killer feature of Go</em>. Asynchronous communication between isolated, concurrent workloads was the use case that made me a Go developer. It&rsquo;s a complex topic, and it can be really easy to do improperly. Heck, I even had to give this little projects a few good go overs to make the example correct.</p><h2 id=concurrent-work>Concurrent work?<a href=#concurrent-work class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Concurrency is the ability of a program to do a collective piece of work in chunks. Some pieces of that work take longer than others, and sometimes the order in which work is performed does not matter. We can use Goroutines to piece out this work, letting the scheduler start and stop processes as necessary. If you would like some very Go-specific information about the language implementation of concurrency, I <em>highly</em> recommend reading the <a href=https://go.dev/doc/effective_go#concurrency>Concurrency section of <em>Effective Go</em> on go.dev</a>.</p><h2 id=a-refresher>A refresher<a href=#a-refresher class=hanchor arialabel=Anchor>&#8983;</a></h2><p>This code (found in my <a href=https://github.com/wgeorgecook/goroutines-in-a-mine>Github repo here</a>) utilizes interfaces in a similar way I explained in <a href=https://williamcook.dev/posts/botanical_exploration_of_abstract_types_in_go/>my botanical exploration of abstract types in Go</a> blog post. There is also code generated via <code>go:generate</code> comments. Which you can learn more about <a href=https://williamcook.dev/posts/go_generate_protobuf/>in my post about using Go Generate for Protobuf</a>. Neither of those are required reading, but can help you understand the code a little better if some of these topics are a little foreign to you.</p><h2 id=more-than-one-way-to-mine-some-diamonds>More Than One Way to Mine Some Diamonds<a href=#more-than-one-way-to-mine-some-diamonds class=hanchor arialabel=Anchor>&#8983;</a></h2><p>If you&rsquo;ve ever spent several days mining some land under your base in <em>Minecraft</em>, then you know there&rsquo;s lots of different ways to get those diamonds. You can dig some nice long strips running parallel to catch as much at one level as you want. You can find a cave system and go spellunking until you happen upon a diamond vein. You can load up on TNT and blow up everything within a couple of chunks and catch what&rsquo;s left over. You can group up with friends. You can take some solo time. It doesn&rsquo;t matter how the diamonds are found, it only matters that they are.</p><h2 id=worker-patterns-in-go>Worker Patterns in Go<a href=#worker-patterns-in-go class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Many times you want to implement the same pattern in your program. You can have a stream of work and you need to make a few different database calls to build a response. Some data from Mongo, a little bit of Postgres. Grab some data from an S3 bucket. Whatever! The pieces are entirely independent of each other, so they don&rsquo;t need to wait for each other to complete before another can start working again. Now, if you will excuse my brief foray into practicallity, we can resume the contriving.</p><h2 id=high-ho>High Ho!<a href=#high-ho class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Let&rsquo;s look at some code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>inChan</span> = make(<span style=color:#a6e22e>channeling</span>.<span style=color:#a6e22e>InputChan</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>errChan</span> = make(<span style=color:#a6e22e>channeling</span>.<span style=color:#a6e22e>ErrChan</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>doneChan</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>workChan</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the <code>init</code> function, I create several channels. Channels are the way Goroutines communicate with each other. If you can tell from the context, these are channels for input workers, error reporting, to indicate when work is done, and work to do. The channels are empty though, so let&rsquo;s fill them up.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>name</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>names</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>inChan</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>worker</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>workChan</span>)
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>The syntax is pretty simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>chanToReceive</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>thingToSend</span>
</span></span></code></pre></div><p>Similarly, we can read from channels in a loop. Let&rsquo;s examine the <code>channeling</code> package.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Process</span>(<span style=color:#a6e22e>inChan</span> <span style=color:#a6e22e>InputChan</span>, <span style=color:#a6e22e>errChan</span> <span style=color:#a6e22e>ErrChan</span>, <span style=color:#a6e22e>done</span> <span style=color:#a6e22e>DoneChan</span>, <span style=color:#a6e22e>workChan</span> <span style=color:#a6e22e>WorkChan</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>doWork</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#a6e22e>Input</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>DoWork</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>errChan</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Process is listening...&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>doneCounter</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>inChan</span>:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>doWork</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>workChan</span>:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>doneCounter</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>doneCounter</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>7</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To read from a channel, you can either assign it using the walrus or use it a signal. In either case, you&rsquo;ll want a <code>select</code> (if reading from multiple channels) or use <code>range</code> on a single channel.</p><h2 id=off-to-work-we-go>Off to Work We Go<a href=#off-to-work-we-go class=hanchor arialabel=Anchor>&#8983;</a></h2><p>A keen observer noticed that <code>Process</code> function above reads from the <code>inChan</code> and assigns it to <code>i</code>. It then calls <code>doWork</code> passing <code>i</code> in as an argument. But we do something special with this function call. It&rsquo;s all about those two magic letters <code>g</code> and <code>o</code>. Goroutines are spawned when you call a function (either named or anonymous) using the <code>go</code> keyword. When a function is called this way, the work is passed off to the scheduler and it unblocks the function it was called from. In the instances of our hard working dwarfs, their work takes an arbitrary amount of time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#a6e22e>Dwarf</span>) <span style=color:#a6e22e>DoWork</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>logStep</span>(<span style=color:#e6db74>&#34;doing some work!&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>sendDone</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>randTime</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Int</span>() <span style=color:#f92672>%</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#a6e22e>randTime</span><span style=color:#f92672>/</span><span style=color:#ae81ff>5</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>randTime</span><span style=color:#f92672>%</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>Error</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>logStep</span>(<span style=color:#e6db74>&#34;success!&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Without using Goroutines, all of this sleepiness could prevent other dwarves from completing their work in a timely manner!</p><h2 id=synchronous-but-with-extra-steps>Synchronous, But With Extra Steps<a href=#synchronous-but-with-extra-steps class=hanchor arialabel=Anchor>&#8983;</a></h2><p>It&rsquo;s important to test your application and ensure that you have the right code design. You could very likely be implenting a purely synchronous workflow by missing a goroutine, or by locking until one goroutine exits. On the other end, you could get deadlock by preventing your goroutines from exiting (but keeping them alive)!</p><h2 id=raise-your-own-pickaxe>Raise Your Own Pickaxe<a href=#raise-your-own-pickaxe class=hanchor arialabel=Anchor>&#8983;</a></h2><p>There&rsquo;s enough code in this repo for you to see how to handle error reporting when doing work in goroutines. You can implement contexts to end work early if it&rsquo;s not needed anymore. Explore how you can use a <code>sync.WaitGroup</code> to handle the blocking. Thinking in asynchronous processes requires a bit of a paradigm shift. Build the program (<code>go build .</code> or <code>go run main.go</code>) and watch the work queue up and finish in a non-deterministic way. So please experiment and discover what treasures await to those willing to venture the depths of this mine 💎</p></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://williamcook.dev/assets/main.js></script><script src=https://williamcook.dev/assets/prism.js></script></div></body></html>