<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on</title><link>https://williamcook.dev/tags/golang/</link><description>Recent content in Golang on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 22 Sep 2024 22:02:04 -0400</lastBuildDate><atom:link href="https://williamcook.dev/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Goroutines in a Mine</title><link>https://williamcook.dev/posts/goroutines-in-a-mine/</link><pubDate>Sun, 22 Sep 2024 22:02:04 -0400</pubDate><guid>https://williamcook.dev/posts/goroutines-in-a-mine/</guid><description>&lt;h1 id="a-canary-in-a-gem-mine">A Canary? In a Gem Mine?&lt;/h1>
&lt;p>Goroutines are, for me, &lt;em>the killer feature of Go&lt;/em>. Asynchronous communication between isolated, concurrent workloads was the use case that made me a Go developer. It&amp;rsquo;s a complex topic, and it can be really easy to do improperly. Heck, I even had to give this little projects a few good go overs to make the example correct.&lt;/p>
&lt;h2 id="concurrent-work">Concurrent work?&lt;/h2>
&lt;p>Concurrency is the ability of a program to do a collective piece of work in chunks. Some pieces of that work take longer than others, and sometimes the order in which work is performed does not matter. We can use Goroutines to piece out this work, letting the scheduler start and stop processes as necessary. If you would like some very Go-specific information about the language implementation of concurrency, I &lt;em>highly&lt;/em> recommend reading the &lt;a href="https://go.dev/doc/effective_go#concurrency">Concurrency section of &lt;em>Effective Go&lt;/em> on go.dev&lt;/a>.&lt;/p></description><content>&lt;h1 id="a-canary-in-a-gem-mine">A Canary? In a Gem Mine?&lt;/h1>
&lt;p>Goroutines are, for me, &lt;em>the killer feature of Go&lt;/em>. Asynchronous communication between isolated, concurrent workloads was the use case that made me a Go developer. It&amp;rsquo;s a complex topic, and it can be really easy to do improperly. Heck, I even had to give this little projects a few good go overs to make the example correct.&lt;/p>
&lt;h2 id="concurrent-work">Concurrent work?&lt;/h2>
&lt;p>Concurrency is the ability of a program to do a collective piece of work in chunks. Some pieces of that work take longer than others, and sometimes the order in which work is performed does not matter. We can use Goroutines to piece out this work, letting the scheduler start and stop processes as necessary. If you would like some very Go-specific information about the language implementation of concurrency, I &lt;em>highly&lt;/em> recommend reading the &lt;a href="https://go.dev/doc/effective_go#concurrency">Concurrency section of &lt;em>Effective Go&lt;/em> on go.dev&lt;/a>.&lt;/p>
&lt;h2 id="a-refresher">A refresher&lt;/h2>
&lt;p>This code (found in my &lt;a href="https://github.com/wgeorgecook/goroutines-in-a-mine">Github repo here&lt;/a>) utilizes interfaces in a similar way I explained in &lt;a href="https://williamcook.dev/posts/botanical_exploration_of_abstract_types_in_go/">my botanical exploration of abstract types in Go&lt;/a> blog post. There is also code generated via &lt;code>go:generate&lt;/code> comments. Which you can learn more about &lt;a href="https://williamcook.dev/posts/go_generate_protobuf/">in my post about using Go Generate for Protobuf&lt;/a>. Neither of those are required reading, but can help you understand the code a little better if some of these topics are a little foreign to you.&lt;/p>
&lt;h2 id="more-than-one-way-to-mine-some-diamonds">More Than One Way to Mine Some Diamonds&lt;/h2>
&lt;p>If you&amp;rsquo;ve ever spent several days mining some land under your base in &lt;em>Minecraft&lt;/em>, then you know there&amp;rsquo;s lots of different ways to get those diamonds. You can dig some nice long strips running parallel to catch as much at one level as you want. You can find a cave system and go spellunking until you happen upon a diamond vein. You can load up on TNT and blow up everything within a couple of chunks and catch what&amp;rsquo;s left over. You can group up with friends. You can take some solo time. It doesn&amp;rsquo;t matter how the diamonds are found, it only matters that they are.&lt;/p>
&lt;h2 id="worker-patterns-in-go">Worker Patterns in Go&lt;/h2>
&lt;p>Many times you want to implement the same pattern in your program. You can have a stream of work and you need to make a few different database calls to build a response. Some data from Mongo, a little bit of Postgres. Grab some data from an S3 bucket. Whatever! The pieces are entirely independent of each other, so they don&amp;rsquo;t need to wait for each other to complete before another can start working again. Now, if you will excuse my brief foray into practicallity, we can resume the contriving.&lt;/p>
&lt;h2 id="high-ho">High Ho!&lt;/h2>
&lt;p>Let&amp;rsquo;s look at some code.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">inChan&lt;/span> = make(&lt;span style="color:#a6e22e">channeling&lt;/span>.&lt;span style="color:#a6e22e">InputChan&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">errChan&lt;/span> = make(&lt;span style="color:#a6e22e">channeling&lt;/span>.&lt;span style="color:#a6e22e">ErrChan&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">doneChan&lt;/span> = make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">workChan&lt;/span> = make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the &lt;code>init&lt;/code> function, I create several channels. Channels are the way Goroutines communicate with each other. If you can tell from the context, these are channels for input workers, error reporting, to indicate when work is done, and work to do. The channels are empty though, so let&amp;rsquo;s fill them up.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">names&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">inChan&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#a6e22e">worker&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#a6e22e">workChan&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The syntax is pretty simple:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">chanToReceive&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#a6e22e">thingToSend&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Similarly, we can read from channels in a loop. Let&amp;rsquo;s examine the &lt;code>channeling&lt;/code> package.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Process&lt;/span>(&lt;span style="color:#a6e22e">inChan&lt;/span> &lt;span style="color:#a6e22e">InputChan&lt;/span>, &lt;span style="color:#a6e22e">errChan&lt;/span> &lt;span style="color:#a6e22e">ErrChan&lt;/span>, &lt;span style="color:#a6e22e">done&lt;/span> &lt;span style="color:#a6e22e">DoneChan&lt;/span>, &lt;span style="color:#a6e22e">workChan&lt;/span> &lt;span style="color:#a6e22e">WorkChan&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">doWork&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#a6e22e">Input&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>.&lt;span style="color:#a6e22e">DoWork&lt;/span>(); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">errChan&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Process is listening...&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">doneCounter&lt;/span> = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">inChan&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#a6e22e">doWork&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">workChan&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">doneCounter&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">doneCounter&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">done&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>To read from a channel, you can either assign it using the walrus or use it a signal. In either case, you&amp;rsquo;ll want a &lt;code>select&lt;/code> (if reading from multiple channels) or use &lt;code>range&lt;/code> on a single channel.&lt;/p>
&lt;h2 id="off-to-work-we-go">Off to Work We Go&lt;/h2>
&lt;p>A keen observer noticed that &lt;code>Process&lt;/code> function above reads from the &lt;code>inChan&lt;/code> and assigns it to &lt;code>i&lt;/code>. It then calls &lt;code>doWork&lt;/code> passing &lt;code>i&lt;/code> in as an argument. But we do something special with this function call. It&amp;rsquo;s all about those two magic letters &lt;code>g&lt;/code> and &lt;code>o&lt;/code>. Goroutines are spawned when you call a function (either named or anonymous) using the &lt;code>go&lt;/code> keyword. When a function is called this way, the work is passed off to the scheduler and it unblocks the function it was called from. In the instances of our hard working dwarfs, their work takes an arbitrary amount of time.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#a6e22e">Dwarf&lt;/span>) &lt;span style="color:#a6e22e">DoWork&lt;/span>() &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">logStep&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;doing some work!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">sendDone&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">randTime&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Int&lt;/span>() &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Sleep&lt;/span>(&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Duration&lt;/span>(&lt;span style="color:#a6e22e">randTime&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Second&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">randTime&lt;/span>&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">logStep&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;success!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Without using Goroutines, all of this sleepiness could prevent other dwarves from completing their work in a timely manner!&lt;/p>
&lt;h2 id="synchronous-but-with-extra-steps">Synchronous, But With Extra Steps&lt;/h2>
&lt;p>It&amp;rsquo;s important to test your application and ensure that you have the right code design. You could very likely be implenting a purely synchronous workflow by missing a goroutine, or by locking until one goroutine exits. On the other end, you could get deadlock by preventing your goroutines from exiting (but keeping them alive)!&lt;/p>
&lt;h2 id="raise-your-own-pickaxe">Raise Your Own Pickaxe&lt;/h2>
&lt;p>There&amp;rsquo;s enough code in this repo for you to see how to handle error reporting when doing work in goroutines. You can implement contexts to end work early if it&amp;rsquo;s not needed anymore. Explore how you can use a &lt;code>sync.WaitGroup&lt;/code> to handle the blocking. Thinking in asynchronous processes requires a bit of a paradigm shift. Build the program (&lt;code>go build .&lt;/code> or &lt;code>go run main.go&lt;/code>) and watch the work queue up and finish in a non-deterministic way. So please experiment and discover what treasures await to those willing to venture the depths of this mine ðŸ’Ž&lt;/p></content></item><item><title>Botanical_exploration_of_abstract_types_in_go</title><link>https://williamcook.dev/posts/botanical_exploration_of_abstract_types_in_go/</link><pubDate>Wed, 04 Sep 2024 20:42:44 -0400</pubDate><guid>https://williamcook.dev/posts/botanical_exploration_of_abstract_types_in_go/</guid><description>&lt;h1 id="a-forest-full-of-trees">A Forest Full of Trees&lt;/h1>
&lt;p>Are you a Go developer who wants a solid reference for how interfaces and struct composition work? Look no further! Inside the &lt;a href="https://github.com/wgeorgecook/interforestaces">code sample on GitHub&lt;/a> are a few submodules you might find handy. Feel free to open up that repo, but we will be referencing code from it here directly.&lt;/p>
&lt;h2 id="inter-forest-aces">Inter-forest-aces&lt;/h2>
&lt;p>An interface in Go is an abstract type. That is, it describes something without actually embodying the thing itself. Interfaces take this shape:&lt;/p></description><content>&lt;h1 id="a-forest-full-of-trees">A Forest Full of Trees&lt;/h1>
&lt;p>Are you a Go developer who wants a solid reference for how interfaces and struct composition work? Look no further! Inside the &lt;a href="https://github.com/wgeorgecook/interforestaces">code sample on GitHub&lt;/a> are a few submodules you might find handy. Feel free to open up that repo, but we will be referencing code from it here directly.&lt;/p>
&lt;h2 id="inter-forest-aces">Inter-forest-aces&lt;/h2>
&lt;p>An interface in Go is an abstract type. That is, it describes something without actually embodying the thing itself. Interfaces take this shape:&lt;/p>
&lt;pre tabindex="0">&lt;code>type someIFace interface {
someMethod() string
someOtherMethod() int
}
&lt;/code>&lt;/pre>&lt;p>Notice that in &lt;code>someIFace&lt;/code>, there are two methods. One returns a string, and another an int. This is helpful if you want a function that operates on types, but you want to adapt what those types are situationally. To put it into context, take the interface from &lt;code>package trees&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code>// ITree describes an abstract tree
type ITree interface {
GetCategory() string
GetGenus() string
GetSpecies() string
GetCommonName() string
Spring() string
Summer() string
Fall() string
Winter() string
}
&lt;/code>&lt;/pre>&lt;p>The interface says &lt;em>nothing&lt;/em> about any particular tree. It just defines how a concrete tree will describe itself. Some of these methods are &lt;em>implemented&lt;/em> (that is to say, these methods exist) on the concrete type &lt;code>Tree&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code>// Tree is a concrete structure to build a Tree with.
type Tree struct {
genus, species, commonName string
}
// GetGenus returns the genus of the receiving tree.
func (t Tree) GetGenus() string {
return t.genus
}
// GetSpecies returns the species of the receiving tree.
func (t Tree) GetSpecies() string {
return t.species
}
// GetCommonName returns the common name of the receiving tree.
func (t Tree) GetCommonName() string {
return t.commonName
}
&lt;/code>&lt;/pre>&lt;p>However, since &lt;code>Tree&lt;/code> doesn&amp;rsquo;t implement every method of &lt;code>ITree&lt;/code>, it does not &lt;em>satisfy&lt;/em> the interface.&lt;/p>
&lt;h2 id="growing-some-deeper-roots">Growing some deeper roots&lt;/h2>
&lt;p>While a &lt;code>Tree&lt;/code> implements some of the methods that &lt;code>ITree&lt;/code> requires, the methods related to the seaons are left unsatisfied. This is where both packages &lt;code>deciduous&lt;/code> and &lt;code>conifer&lt;/code> come into play.&lt;/p>
&lt;h3 id="planting-a-seed-or-a-struct">Planting a seed (or a struct)&lt;/h3>
&lt;p>If you come from another language, you might be familiar with &lt;em>inheritance&lt;/em>. This is the idea that something (usually a &lt;em>class&lt;/em>) can pass down properties to other things (often called their children). The thing receiving these properties is &lt;em>inheriting&lt;/em> those from its parent. Go doesn&amp;rsquo;t strictly have this, but we have something close called &lt;em>embedding&lt;/em>. When we embed a struct into another, all of the properties of the outer struct are passed down to the struct doing the embedding. Here, both &lt;code>Conifer&lt;/code> and &lt;code>Deciduous&lt;/code> embed the &lt;code>Trees&lt;/code> struct.&lt;/p>
&lt;pre tabindex="0">&lt;code>package conifer
// Confier is type of tree. All fields are
// composed of the Tree type from the trees package.
type Conifer struct {
trees.Tree
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>package deciduous
// Deciduous is type of tree. All fields are
// composed of the Tree type from the trees package.
type Deciduous struct {
trees.Tree
}
&lt;/code>&lt;/pre>&lt;p>Since the &lt;code>trees.Tree&lt;/code> struct has methods like &lt;code>GetCommonName&lt;/code> and properties like &lt;code>Genus&lt;/code> and &lt;code>Species&lt;/code>, these two structs do as well.&lt;/p>
&lt;h2 id="a-fork-in-the-road">A Fork in the Road&lt;/h2>
&lt;p>Conifers and deciduous trees have different lifecyles through. And they experience the turning of the seasons in very different ways. So we would not want them to receive those methods from a common &lt;code>Tree&lt;/code> ancestor. This is why we implement these methods separately for these two different categories of tree. For example:&lt;/p>
&lt;pre tabindex="0">&lt;code>package deciduous
// Spring returns a string representing the
// action deciduous trees take during spring.
func (d Deciduous) Spring() string {
return &amp;#34;Ahhh, new leaves and flowers!&amp;#34;
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>package conifer
// Spring returns a string representing the
// action conifers take during spring.
func (c Conifer) Spring() string {
return &amp;#34;Growing some cones!&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>Both of these methods reveal how both differing kinds of trees experience the same thing in their own special way.&lt;/p>
&lt;h2 id="bring-it-around-the-campfire">Bring it around the campfire&lt;/h2>
&lt;p>As previously mentioned, the real power of an abstract type is to pass it to a function that operates on interfaces. Take a look at the &lt;code>trees.Lifecycle&lt;/code> function.&lt;/p>
&lt;pre tabindex="0">&lt;code>package trees
// Lifecycle iterates over the methods found in ITree to describe
// the argument Tree and it&amp;#39;s life over one year.
func Lifecycle(t ITree) {
fmt.Println(&amp;#34;Hello! I am &amp;#34; + t.GetGenus() + &amp;#34; &amp;#34; + t.GetSpecies() + &amp;#34; (&amp;#34; + t.GetCommonName() + &amp;#34;), &amp;#34; + t.GetCategory() + &amp;#34; tree!&amp;#34;)
fmt.Println(&amp;#34;Today I am going through my lifecycle. Come grow with me!&amp;#34;)
fmt.Println(&amp;#34;It&amp;#39;s Spring! &amp;#34; + t.Spring())
fmt.Println(&amp;#34;Summertime! &amp;#34; + t.Summer())
fmt.Println(&amp;#34;Autumn is here. &amp;#34; + t.Fall())
fmt.Println(&amp;#34;Brrrr winter! &amp;#34; + t.Winter())
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>Lifecycle&lt;/code> does one thing - it progresses through a year of whatever &lt;code>ITree&lt;/code> is passed into it. It does not care whether the &lt;code>ITree&lt;/code> is deciduous, a conifer, or a new, third type! But rather than having &lt;code>deciduous.Lifecycle&lt;/code> and &lt;code>conifer.Lifecycle&lt;/code>, you can have this one place to make these &lt;code>ITree&lt;/code>s grow. Now how neat is that?&lt;/p>
&lt;h2 id="the-wilderness-must-be-explored">The wilderness must be explored!&lt;/h2>
&lt;p>Have some fun with this. Create some new types of trees that implement the &lt;code>ITree&lt;/code> interface. Or maybe rename &lt;code>ITree&lt;/code> to &lt;code>IPlant&lt;/code> and create some &lt;code>vascular&lt;/code> and &lt;code>nonvascular&lt;/code> plant types and let &lt;code>deciduous&lt;/code> and &lt;code>conifer&lt;/code> embed those structs as necessary. Test yourself too. Knowing now what you do about interfaces, do you know why &lt;code>trees.New()&lt;/code> can&amp;rsquo;t be passed into the &lt;code>trees.Lifecycle()&lt;/code> function, but both a &lt;code>conifer.New()&lt;/code> and a &lt;code>deciduous.New()&lt;/code> can?&lt;/p></content></item><item><title>Go_generate_protobuf</title><link>https://williamcook.dev/posts/go_generate_protobuf/</link><pubDate>Tue, 03 Sep 2024 14:30:59 -0400</pubDate><guid>https://williamcook.dev/posts/go_generate_protobuf/</guid><description>&lt;h1 id="playground-for-go-generate-using-proto-files">Playground for Go Generate Using Proto Files&lt;/h1>
&lt;p>This is a small application to demonstrate how to use &lt;code>go generate&lt;/code> to compile proto files into Go code.&lt;/p>
&lt;p>Note: all code is available on GitHub &lt;a href="https://github.com/wgeorgecook/playgen">here&lt;/a>.&lt;/p>
&lt;h2 id="go-generate">Go Generate&lt;/h2>
&lt;p>The &lt;a href="https://go.dev/blog/generate">original blog post&lt;/a> by Rob Pike is well worth a read.
At the bottom, Rob says&lt;/p>
&lt;blockquote>
&lt;p>Please use go generate creatively. Itâ€™s there to encourage experimentation.&lt;/p>
&lt;/blockquote>
&lt;p>This is one such experimentation.&lt;/p>
&lt;h2 id="protobuf-gprc-and-generating-code">Protobuf, gPRC, and Generating Code&lt;/h2>
&lt;p>If you are unfamiliar with &lt;a href="https://protobuf.dev/">Protocol Buffers&lt;/a> and &lt;a href="https://grpc.io/docs/languages/go/quickstart/">gRPC&lt;/a>, those linked resources are worth a read. However, just know that Protobuf is a language spec that allows you to define abstract API contracts within generated code stubs. Your application needs to implement these interfaces for clients to consume. The benefit is that both client and server consume and fulfill requests using the same base &lt;code>.proto&lt;/code> file and its generated code, allowing for incredible type safety.&lt;/p></description><content>&lt;h1 id="playground-for-go-generate-using-proto-files">Playground for Go Generate Using Proto Files&lt;/h1>
&lt;p>This is a small application to demonstrate how to use &lt;code>go generate&lt;/code> to compile proto files into Go code.&lt;/p>
&lt;p>Note: all code is available on GitHub &lt;a href="https://github.com/wgeorgecook/playgen">here&lt;/a>.&lt;/p>
&lt;h2 id="go-generate">Go Generate&lt;/h2>
&lt;p>The &lt;a href="https://go.dev/blog/generate">original blog post&lt;/a> by Rob Pike is well worth a read.
At the bottom, Rob says&lt;/p>
&lt;blockquote>
&lt;p>Please use go generate creatively. Itâ€™s there to encourage experimentation.&lt;/p>
&lt;/blockquote>
&lt;p>This is one such experimentation.&lt;/p>
&lt;h2 id="protobuf-gprc-and-generating-code">Protobuf, gPRC, and Generating Code&lt;/h2>
&lt;p>If you are unfamiliar with &lt;a href="https://protobuf.dev/">Protocol Buffers&lt;/a> and &lt;a href="https://grpc.io/docs/languages/go/quickstart/">gRPC&lt;/a>, those linked resources are worth a read. However, just know that Protobuf is a language spec that allows you to define abstract API contracts within generated code stubs. Your application needs to implement these interfaces for clients to consume. The benefit is that both client and server consume and fulfill requests using the same base &lt;code>.proto&lt;/code> file and its generated code, allowing for incredible type safety.&lt;/p>
&lt;h2 id="protoc-hassles">Protoc Hassles&lt;/h2>
&lt;p>Go developers using Protobuf for a few years are probably familiar with the &lt;code>protoc&lt;/code> binary used and the &lt;code>protoc-gen-go&lt;/code> plugin. This is the tool we use to generate Go stubs from proto files. Protoc commands can be provided via scripts, in Dockerfiles, or ran directly to ensure that code is generated and types are accessible to your application. This decouples the proto compilation step from your app compilation. If you want to couple the two together, &lt;code>go generate&lt;/code> may be your answer.&lt;/p>
&lt;h1 id="go-generate-again">Go Generate (again)&lt;/h1>
&lt;p>The &lt;code>go generate&lt;/code> command searches through your Go files for the &lt;code>//go:generate&lt;/code> comment (notice no space between the slashes and &lt;code>go&lt;/code>). Adding this tag tells the Go toolchain to run whatever shell commends follow.&lt;/p>
&lt;h2 id="tagging-for-go-generate">Tagging for Go Generate&lt;/h2>
&lt;p>You can see here that &lt;code>main.go&lt;/code> has two go generate tags.&lt;/p>
&lt;pre tabindex="0">&lt;code>//go:generate protoc --go_out=. --go-grpc_out=. proto/helloapis/messages.proto
//go:generate protoc --go_out=. --go-grpc_out=. proto/helloapis/services.proto
&lt;/code>&lt;/pre>&lt;p>These two tags will compile protos found in &lt;code>proto/helloapis&lt;/code> and move them into the directory indicated by their package name. In this instance, that directory is &lt;code>gen/helloapis/v1&lt;/code>.&lt;/p>
&lt;h1 id="building-the-application">Building the Application&lt;/h1>
&lt;p>Attemping to run &lt;code>go build .&lt;/code> before compiling the protos will fail.&lt;/p>
&lt;blockquote>
&lt;p>â¯ go build .
client/client.go:6:2: package playgen/gen/helloapis/v1 is not in std (/snap/go/10630/src/playgen/gen/helloapis/v1)&lt;/p>
&lt;/blockquote>
&lt;p>To resolve this, run &lt;code>go generate ./...&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>â¯ go generate ./&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>Notice that a new &lt;code>gen&lt;/code> directory is in the repo root.&lt;/p>
&lt;pre tabindex="0">&lt;code>â¯ ls
build client docker-compose.yaml gen go.mod go.sum main.go proto README.md server
&lt;/code>&lt;/pre>&lt;p>The application is now buildable and runnable!&lt;/p>
&lt;pre tabindex="0">&lt;code>â¯ go build .
â¯ ls
build client docker-compose.yaml gen go.mod go.sum main.go playgen proto README.md server
â¯ ./playgen
Hello, vim-go!
&lt;/code>&lt;/pre></content></item></channel></rss>