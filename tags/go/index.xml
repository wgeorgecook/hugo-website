<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on</title><link>https://williamcook.dev/tags/go/</link><description>Recent content in Go on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 04 Sep 2024 20:42:44 -0400</lastBuildDate><atom:link href="https://williamcook.dev/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Botanical_exploration_of_abstract_types_in_go</title><link>https://williamcook.dev/posts/botanical_exploration_of_abstract_types_in_go/</link><pubDate>Wed, 04 Sep 2024 20:42:44 -0400</pubDate><guid>https://williamcook.dev/posts/botanical_exploration_of_abstract_types_in_go/</guid><description>&lt;h1 id="a-forest-full-of-trees">A Forest Full of Trees&lt;/h1>
&lt;p>Are you a Go developer who wants a solid reference for how interfaces and struct composition work? Look no further! Inside the &lt;a href="https://github.com/wgeorgecook/interforestaces">code sample on GitHub&lt;/a> are a few submodules you might find handy. Feel free to open up that repo, but we will be referencing code from it here directly.&lt;/p>
&lt;h2 id="inter-forest-aces">Inter-forest-aces&lt;/h2>
&lt;p>An interface in Go is an abstract type. That is, it describes something without actually embodying the thing itself. Interfaces take this shape:&lt;/p></description><content>&lt;h1 id="a-forest-full-of-trees">A Forest Full of Trees&lt;/h1>
&lt;p>Are you a Go developer who wants a solid reference for how interfaces and struct composition work? Look no further! Inside the &lt;a href="https://github.com/wgeorgecook/interforestaces">code sample on GitHub&lt;/a> are a few submodules you might find handy. Feel free to open up that repo, but we will be referencing code from it here directly.&lt;/p>
&lt;h2 id="inter-forest-aces">Inter-forest-aces&lt;/h2>
&lt;p>An interface in Go is an abstract type. That is, it describes something without actually embodying the thing itself. Interfaces take this shape:&lt;/p>
&lt;pre tabindex="0">&lt;code>type someIFace interface {
someMethod() string
someOtherMethod() int
}
&lt;/code>&lt;/pre>&lt;p>Notice that in &lt;code>someIFace&lt;/code>, there are two methods. One returns a string, and another an int. This is helpful if you want a function that operates on types, but you want to adapt what those types are situationally. To put it into context, take the interface from &lt;code>package trees&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code>// ITree describes an abstract tree
type ITree interface {
GetCategory() string
GetGenus() string
GetSpecies() string
GetCommonName() string
Spring() string
Summer() string
Fall() string
Winter() string
}
&lt;/code>&lt;/pre>&lt;p>The interface says &lt;em>nothing&lt;/em> about any particular tree. It just defines how a concrete tree will describe itself. Some of these methods are &lt;em>implemented&lt;/em> (that is to say, these methods exist) on the concrete type &lt;code>Tree&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code>// Tree is a concrete structure to build a Tree with.
type Tree struct {
genus, species, commonName string
}
// GetGenus returns the genus of the receiving tree.
func (t Tree) GetGenus() string {
return t.genus
}
// GetSpecies returns the species of the receiving tree.
func (t Tree) GetSpecies() string {
return t.species
}
// GetCommonName returns the common name of the receiving tree.
func (t Tree) GetCommonName() string {
return t.commonName
}
&lt;/code>&lt;/pre>&lt;p>However, since &lt;code>Tree&lt;/code> doesn&amp;rsquo;t implement every method of &lt;code>ITree&lt;/code>, it does not &lt;em>satisfy&lt;/em> the interface.&lt;/p>
&lt;h2 id="growing-some-deeper-roots">Growing some deeper roots&lt;/h2>
&lt;p>While a &lt;code>Tree&lt;/code> implements some of the methods that &lt;code>ITree&lt;/code> requires, the methods related to the seaons are left unsatisfied. This is where both packages &lt;code>deciduous&lt;/code> and &lt;code>conifer&lt;/code> come into play.&lt;/p>
&lt;h3 id="planting-a-seed-or-a-struct">Planting a seed (or a struct)&lt;/h3>
&lt;p>If you come from another language, you might be familiar with &lt;em>inheritance&lt;/em>. This is the idea that something (usually a &lt;em>class&lt;/em>) can pass down properties to other things (often called their children). The thing receiving these properties is &lt;em>inheriting&lt;/em> those from its parent. Go doesn&amp;rsquo;t strictly have this, but we have something close called &lt;em>embedding&lt;/em>. When we embed a struct into another, all of the properties of the outer struct are passed down to the struct doing the embedding. Here, both &lt;code>Conifer&lt;/code> and &lt;code>Deciduous&lt;/code> embed the &lt;code>Trees&lt;/code> struct.&lt;/p>
&lt;pre tabindex="0">&lt;code>package conifer
// Confier is type of tree. All fields are
// composed of the Tree type from the trees package.
type Conifer struct {
trees.Tree
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>package deciduous
// Deciduous is type of tree. All fields are
// composed of the Tree type from the trees package.
type Deciduous struct {
trees.Tree
}
&lt;/code>&lt;/pre>&lt;p>Since the &lt;code>trees.Tree&lt;/code> struct has methods like &lt;code>GetCommonName&lt;/code> and properties like &lt;code>Genus&lt;/code> and &lt;code>Species&lt;/code>, these two structs do as well.&lt;/p>
&lt;h2 id="a-fork-in-the-road">A Fork in the Road&lt;/h2>
&lt;p>Conifers and deciduous trees have different lifecyles through. And they experience the turning of the seasons in very different ways. So we would not want them to receive those methods from a common &lt;code>Tree&lt;/code> ancestor. This is why we implement these methods separately for these two different categories of tree. For example:&lt;/p>
&lt;pre tabindex="0">&lt;code>package deciduous
// Spring returns a string representing the
// action deciduous trees take during spring.
func (d Deciduous) Spring() string {
return &amp;#34;Ahhh, new leaves and flowers!&amp;#34;
}
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>package conifer
// Spring returns a string representing the
// action conifers take during spring.
func (c Conifer) Spring() string {
return &amp;#34;Growing some cones!&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>Both of these methods reveal how both differing kinds of trees experience the same thing in their own special way.&lt;/p>
&lt;h2 id="bring-it-around-the-campfire">Bring it around the campfire&lt;/h2>
&lt;p>As previously mentioned, the real power of an abstract type is to pass it to a function that operates on interfaces. Take a look at the &lt;code>trees.Lifecycle&lt;/code> function.&lt;/p>
&lt;pre tabindex="0">&lt;code>package trees
// Lifecycle iterates over the methods found in ITree to describe
// the argument Tree and it&amp;#39;s life over one year.
func Lifecycle(t ITree) {
fmt.Println(&amp;#34;Hello! I am &amp;#34; + t.GetGenus() + &amp;#34; &amp;#34; + t.GetSpecies() + &amp;#34; (&amp;#34; + t.GetCommonName() + &amp;#34;), &amp;#34; + t.GetCategory() + &amp;#34; tree!&amp;#34;)
fmt.Println(&amp;#34;Today I am going through my lifecycle. Come grow with me!&amp;#34;)
fmt.Println(&amp;#34;It&amp;#39;s Spring! &amp;#34; + t.Spring())
fmt.Println(&amp;#34;Summertime! &amp;#34; + t.Summer())
fmt.Println(&amp;#34;Autumn is here. &amp;#34; + t.Fall())
fmt.Println(&amp;#34;Brrrr winter! &amp;#34; + t.Winter())
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>Lifecycle&lt;/code> does one thing - it progresses through a year of whatever &lt;code>ITree&lt;/code> is passed into it. It does not care whether the &lt;code>ITree&lt;/code> is deciduous, a conifer, or a new, third type! But rather than having &lt;code>deciduous.Lifecycle&lt;/code> and &lt;code>conifer.Lifecycle&lt;/code>, you can have this one place to make these &lt;code>ITree&lt;/code>s grow. Now how neat is that?&lt;/p>
&lt;h2 id="the-wilderness-must-be-explored">The wilderness must be explored!&lt;/h2>
&lt;p>Have some fun with this. Create some new types of trees that implement the &lt;code>ITree&lt;/code> interface. Or maybe rename &lt;code>ITree&lt;/code> to &lt;code>IPlant&lt;/code> and create some &lt;code>vascular&lt;/code> and &lt;code>nonvascular&lt;/code> plant types and let &lt;code>deciduous&lt;/code> and &lt;code>conifer&lt;/code> embed those structs as necessary. Test yourself too. Knowing now what you do about interfaces, do you know why &lt;code>trees.New()&lt;/code> can&amp;rsquo;t be passed into the &lt;code>trees.Lifecycle()&lt;/code> function, but both a &lt;code>conifer.New()&lt;/code> and a &lt;code>deciduous.New()&lt;/code> can?&lt;/p></content></item><item><title>Go_generate_protobuf</title><link>https://williamcook.dev/posts/go_generate_protobuf/</link><pubDate>Tue, 03 Sep 2024 14:30:59 -0400</pubDate><guid>https://williamcook.dev/posts/go_generate_protobuf/</guid><description>&lt;h1 id="playground-for-go-generate-using-proto-files">Playground for Go Generate Using Proto Files&lt;/h1>
&lt;p>This is a small application to demonstrate how to use &lt;code>go generate&lt;/code> to compile proto files into Go code.&lt;/p>
&lt;p>Note: all code is available on GitHub &lt;a href="https://github.com/wgeorgecook/playgen">here&lt;/a>.&lt;/p>
&lt;h2 id="go-generate">Go Generate&lt;/h2>
&lt;p>The &lt;a href="https://go.dev/blog/generate">original blog post&lt;/a> by Rob Pike is well worth a read.
At the bottom, Rob says&lt;/p>
&lt;blockquote>
&lt;p>Please use go generate creatively. It’s there to encourage experimentation.&lt;/p></description><content>&lt;h1 id="playground-for-go-generate-using-proto-files">Playground for Go Generate Using Proto Files&lt;/h1>
&lt;p>This is a small application to demonstrate how to use &lt;code>go generate&lt;/code> to compile proto files into Go code.&lt;/p>
&lt;p>Note: all code is available on GitHub &lt;a href="https://github.com/wgeorgecook/playgen">here&lt;/a>.&lt;/p>
&lt;h2 id="go-generate">Go Generate&lt;/h2>
&lt;p>The &lt;a href="https://go.dev/blog/generate">original blog post&lt;/a> by Rob Pike is well worth a read.
At the bottom, Rob says&lt;/p>
&lt;blockquote>
&lt;p>Please use go generate creatively. It’s there to encourage experimentation.&lt;/p>
&lt;/blockquote>
&lt;p>This is one such experimentation.&lt;/p>
&lt;h2 id="protobuf-gprc-and-generating-code">Protobuf, gPRC, and Generating Code&lt;/h2>
&lt;p>If you are unfamiliar with &lt;a href="https://protobuf.dev/">Protocol Buffers&lt;/a> and &lt;a href="https://grpc.io/docs/languages/go/quickstart/">gRPC&lt;/a>, those linked resources are worth a read. However, just know that Protobuf is a language spec that allows you to define abstract API contracts within generated code stubs. Your application needs to implement these interfaces for clients to consume. The benefit is that both client and server consume and fulfill requests using the same base &lt;code>.proto&lt;/code> file and its generated code, allowing for incredible type safety.&lt;/p>
&lt;h2 id="protoc-hassles">Protoc Hassles&lt;/h2>
&lt;p>Go developers using Protobuf for a few years are probably familiar with the &lt;code>protoc&lt;/code> binary used and the &lt;code>protoc-gen-go&lt;/code> plugin. This is the tool we use to generate Go stubs from proto files. Protoc commands can be provided via scripts, in Dockerfiles, or ran directly to ensure that code is generated and types are accessible to your application. This decouples the proto compilation step from your app compilation. If you want to couple the two together, &lt;code>go generate&lt;/code> may be your answer.&lt;/p>
&lt;h1 id="go-generate-again">Go Generate (again)&lt;/h1>
&lt;p>The &lt;code>go generate&lt;/code> command searches through your Go files for the &lt;code>//go:generate&lt;/code> comment (notice no space between the slashes and &lt;code>go&lt;/code>). Adding this tag tells the Go toolchain to run whatever shell commends follow.&lt;/p>
&lt;h2 id="tagging-for-go-generate">Tagging for Go Generate&lt;/h2>
&lt;p>You can see here that &lt;code>main.go&lt;/code> has two go generate tags.&lt;/p>
&lt;pre tabindex="0">&lt;code>//go:generate protoc --go_out=. --go-grpc_out=. proto/helloapis/messages.proto
//go:generate protoc --go_out=. --go-grpc_out=. proto/helloapis/services.proto
&lt;/code>&lt;/pre>&lt;p>These two tags will compile protos found in &lt;code>proto/helloapis&lt;/code> and move them into the directory indicated by their package name. In this instance, that directory is &lt;code>gen/helloapis/v1&lt;/code>.&lt;/p>
&lt;h1 id="building-the-application">Building the Application&lt;/h1>
&lt;p>Attemping to run &lt;code>go build .&lt;/code> before compiling the protos will fail.&lt;/p>
&lt;blockquote>
&lt;p>❯ go build .
client/client.go:6:2: package playgen/gen/helloapis/v1 is not in std (/snap/go/10630/src/playgen/gen/helloapis/v1)&lt;/p>
&lt;/blockquote>
&lt;p>To resolve this, run &lt;code>go generate ./...&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>❯ go generate ./&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>Notice that a new &lt;code>gen&lt;/code> directory is in the repo root.&lt;/p>
&lt;pre tabindex="0">&lt;code>❯ ls
build client docker-compose.yaml gen go.mod go.sum main.go proto README.md server
&lt;/code>&lt;/pre>&lt;p>The application is now buildable and runnable!&lt;/p>
&lt;pre tabindex="0">&lt;code>❯ go build .
❯ ls
build client docker-compose.yaml gen go.mod go.sum main.go playgen proto README.md server
❯ ./playgen
Hello, vim-go!
&lt;/code>&lt;/pre></content></item><item><title>Functional_options_golang</title><link>https://williamcook.dev/posts/functional_options_golang/</link><pubDate>Wed, 07 Aug 2024 21:08:38 -0400</pubDate><guid>https://williamcook.dev/posts/functional_options_golang/</guid><description>&lt;h1 id="lets-say">Lets say&amp;hellip;&lt;/h1>
&lt;p>You are the maintainer of a widely used function in a fairly large service. This function abstracts away
all of the boilerplate necessary to log an error. The wider service has several different debugging tools.
For example, it could:&lt;/p>
&lt;ol>
&lt;li>Log errors to &lt;a href="https://rollbar.com">Rollbar&lt;/a>&lt;/li>
&lt;li>Instrument &lt;a href="https://opentelemetry.io/">OpenTelemetry&lt;/a>&lt;/li>
&lt;li>Support logging to stdout, to disk, or an async log aggregator.&lt;/li>
&lt;/ol>
&lt;p>the list can theoretically go on and on.&lt;/p></description><content>&lt;h1 id="lets-say">Lets say&amp;hellip;&lt;/h1>
&lt;p>You are the maintainer of a widely used function in a fairly large service. This function abstracts away
all of the boilerplate necessary to log an error. The wider service has several different debugging tools.
For example, it could:&lt;/p>
&lt;ol>
&lt;li>Log errors to &lt;a href="https://rollbar.com">Rollbar&lt;/a>&lt;/li>
&lt;li>Instrument &lt;a href="https://opentelemetry.io/">OpenTelemetry&lt;/a>&lt;/li>
&lt;li>Support logging to stdout, to disk, or an async log aggregator.&lt;/li>
&lt;/ol>
&lt;p>the list can theoretically go on and on.&lt;/p>
&lt;h2 id="logerrorss-humble-beginnings">LogErrors&amp;rsquo;s Humble Beginnings&lt;/h2>
&lt;p>To start, you write your function to support your own use case, and make the api easy to consume for others.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">func LogError(e error, msg string) {
// assume a logger is configured
logger.Error(e.Error + &amp;#34;: &amp;#34; + msg)
}
&lt;/code>&lt;/pre>&lt;p>This is a simple enough function that formats an error and invokes the configured logger at the Error level.&lt;/p>
&lt;h2 id="logerrors-organic-growth">LogError&amp;rsquo;s Organic Growth&lt;/h2>
&lt;p>As this service matures, things can get out of hand. Let&amp;rsquo;s introduce some other, optional dependencies in a naive way.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">func LogError(e error, msg string, shouldRollbar bool, spanCtx context.Context) {
fmtErr := e.Error + &amp;#34;: &amp;#34; + msg
if shouldRollbar {
rollbar.Error(fmtErr)
}
if spanCtx != nil {
span := otel.NewSpan(&amp;#34;LogError&amp;#34;, spanCtx)
defer span.End()
span.RecordError(fmtErr)
}
logger.Error(fmtErr)
}
&lt;/code>&lt;/pre>&lt;p>This is fine and functional, but you can see how adding additional, optional features requires a full refactor of every function call. Furthermore, the caller has to populate these arguments even if they are falsy or &lt;code>nil&lt;/code>.&lt;/p>
&lt;h2 id="a-better-way">A Better Way&lt;/h2>
&lt;p>We can enforce some required arguments by defining them as we would before. Let&amp;rsquo;s say that &lt;code>err&lt;/code> and &lt;code>msg&lt;/code> are required params. However, logging to a span or triggering a Rollbar are completely optional. We can save the caller a hastle by not requiring them in the function call at all by using the functional options pattern.&lt;/p>
&lt;h1 id="functional-options">Functional Options&lt;/h1>
&lt;p>We need to create an &lt;code>option&lt;/code> type that we use internally to drive the logic for behavior. Leave this unexported so the caller doesn&amp;rsquo;t try and use it directly.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">type option struct {
withRollbar bool
withContext context.Context
}
&lt;/code>&lt;/pre>&lt;p>The real magic happens when we create a type that returns a function that accepts the option as an argument.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">type Options func(*option)
&lt;/code>&lt;/pre>&lt;p>We now create functions that return the &lt;code>Options&lt;/code> type that the caller can use.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">func WithRollbar() Options {
return func(o *option) {
o.withRollbar = true
}
}
func WithContext(ctx context.Context) Option {
return func(o *option) {
o.withContext = ctx
}
}
&lt;/code>&lt;/pre>&lt;h2 id="leveraging-functional-options">Leveraging Functional Options&lt;/h2>
&lt;p>All of the pieces are coming together, but as &lt;code>LogError&lt;/code> stands, it does not use options. Let&amp;rsquo;s fix that by first changing the function signature.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">func LogError(err error, msg string, opts ...Options) {
// function body
}
&lt;/code>&lt;/pre>&lt;p>Now the &lt;code>err&lt;/code> and &lt;code>message&lt;/code> arguments are required by the compiler (even if nil or empty). The &lt;code>...Options&lt;/code> syntax indicates that &lt;code>LogError&lt;/code> is now a &lt;em>variadic function&lt;/em>, and that the trailing arguments is a slice of length &amp;gt;= 0. The compiler will not enforce that any argument is present for the variadic argument. Functionally this means that &lt;code>opts&lt;/code> is entirely optional! However, we still need to leverage these options within the function.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">func LogError(err error, msg string, opts ...Options) {
fmtErr := err.Error() + &amp;#34;: &amp;#34; + msg
// instantiate an option struct to populate with
// provided options
o := options{}
// iterate through the provided options to populate
// data on the struct
for _, opt := opts {
opt(o)
}
// start performing logic based on provided options
if o.withRollbar {
rollbar.Error(fmtErr)
}
if o.withContext != nil {
span := otel.NewSpan(&amp;#34;LogError&amp;#34;, spanCtx)
defer span.End()
span.RecordError(fmtErr)
}
logger.Error(fmtErr)
}
&lt;/code>&lt;/pre>&lt;p>You can see the function body doesn&amp;rsquo;t change &lt;em>all that much&lt;/em>. But we have significatly reduced the signature and uncomplicated the things the caller needs to worry about.&lt;/p>
&lt;h2 id="using-logerror">Using LogError&lt;/h2>
&lt;p>With functional arguments, all of these are valid invocations of &lt;code>LogError&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">err := errors.New(&amp;#34;there was an error!&amp;#34;)
msg := &amp;#34;could not perform operation&amp;#34;
ctx := context.Background()
LogError(err, msg)
LogError(err, msg, WithContext(ctx))
LogError(err, msg, WithRollbar())
LogError(err, msg, WithContext(ctx), WithRollbar())
LogError(err, msg, WithRollbar(), WithContext(ctx))
&lt;/code>&lt;/pre>&lt;p>Consumers of &lt;code>LogError&lt;/code> now no longer need to worry about providing a nil context or falsy &lt;code>shouldRollbar&lt;/code> value if they are unconcerned about those features.&lt;/p>
&lt;h2 id="extending-logerror">Extending LogError&lt;/h2>
&lt;p>Now that &lt;code>LogError&lt;/code> is a variadic function, we can add more options without needing to refactor any of its consumers. Let&amp;rsquo;s implement optionally logging to disk instead of standard out.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">type option struct {
withRollbar bool
withContext context.Context
withLogToDisk bool // new field
}
func WithLogToDisk() Option {
return func(o *option) {
o.withLogToDisk = true
}
}
func LogError(err error, msg string, opts ...Options) {
fmtErr := err.Error() + &amp;#34;: &amp;#34; + msg
// instantiate an option struct to populate with
// provided options
o := options{}
// iterate through the provided options to populate
// data on the struct
for _, opt := opts {
opt(o)
}
// start performing logic based on provided options
if o.withRollbar {
rollbar.Error(fmtErr)
}
if o.withContext != nil {
span := otel.NewSpan(&amp;#34;LogError&amp;#34;, spanCtx)
defer span.End()
span.RecordError(fmtErr)
}
if o.withLogToDisk {
// helper function assumed to exist
logErrorToDisk(fmtErr)
return
}
logger.Error(fmtErr)
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>LogError&lt;/code> is now more functional for consumers who wish to leverage this option. However, because of the variadic nature of &lt;code>LogError&lt;/code>, we don&amp;rsquo;t need to do a single bit of refactoring the consumers and the api is unchanged. Anyone who wishes to log to disk instead of to standard out can do so like this:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-code" data-lang="code">err := errors.New(&amp;#34;there was an error!&amp;#34;)
msg := &amp;#34;could not perform operation&amp;#34;
LogError(err, msg, WithLogToDisk())
&lt;/code>&lt;/pre>&lt;h1 id="thats-pretty-neat">That&amp;rsquo;s Pretty Neat&lt;/h1>
&lt;p>There is the overhead of planning for which arguments are required and which are options when maintaining a function such as &lt;code>LogError&lt;/code>. However, if you know that the function will be broadly consumed from users with differing needs then utilizing functional options is a great way to implement those dependencies without forcing them on every consumer. Functional options allow for easily extending functionality without requiring large refactors for the consumers of its api.&lt;/p></content></item></channel></rss>